// from now on we use (something very similar to)
// Python syntax
// colons and brackets however can be omitted in most places


// optional colons
for_list: _FOR var _IN var_access (_COLON)? _EOL (_SPACE command) (_EOL _SPACE command)* _EOL? _END_BLOCK

// optional brackets
print: _PRINT _LEFT_BRACKET? (_print_ask_argument)? _RIGHT_BRACKET?

// optional commas between arguments
_print_ask_argument.1: (_SPACE | print_ask_atom | quoted_text | list_access | expression | print_expression | _COMMA)*

//optional colon in if/elses
if_clause: _IF (_conditions) _COLON? _EOL _commands _EOL? _END_BLOCK
else_clause: _SPACE* _ELSE _COLON? _EOL _commands _EOL? _END_BLOCK
elif_clause: _SPACE* _ELIF (_conditions) _COLON? _EOL _commands _EOL? _END_BLOCK

//add input
input_empty_brackets: var (_IS | _EQUALS ) _INPUT (_LEFT_BRACKET _RIGHT_BRACKET)
input: var (_IS | _EQUALS) _INPUT _LEFT_BRACKET _print_ask_argument* _RIGHT_BRACKET

//new : while loop with optional colon
while_loop: _WHILE (_conditions) _COLON? _EOL _commands _EOL? _END_BLOCK

//list access with mandatory (!!) brackets
list_access: var_access _LEFT_SQUARE_BRACKET (INT | random | var_access) _RIGHT_SQUARE_BRACKET
change_list_item: var_access _LEFT_SQUARE_BRACKET (INT | var_access) _RIGHT_SQUARE_BRACKET _EQUALS (var_access | quoted_text | NUMBER  | list_access)
assign: var (_IS | _EQUALS) (INT | atom | list_access | expression | quoted_text | error_list_access_at) _SPACE?
assign_list: var (_IS | _EQUALS) _LEFT_SQUARE_BRACKET ((INT | atom | list_access | expression | quoted_text | error_list_access_at) (_COMMA (INT | atom | list_access | expression | quoted_text  | error_list_access_at))*)? _RIGHT_SQUARE_BRACKET

// adding the new commands
command: += change_list_item | while_loop | for_loop | input | input_empty_brackets | define | call | return | error_for_missing_in | error_for_missing_to | error_for_missing_command | error_assign_list_missing_brackets

//new : for loop
for_loop: _FOR var _IN _RANGE _LEFT_BRACKET? (INT | var_access) _COMMA (INT | var_access) _RIGHT_BRACKET? _COLON? _EOL (_SPACE command) (_EOL _SPACE command)*  _EOL? _END_BLOCK

error_for_missing_in: _FOR var _SPACE _RANGE (INT | var_access)? (_SPACE (INT | var_access))*
error_for_missing_to: _FOR var _IN _RANGE (INT | var_access) _SPACE (INT | var_access) _EOL
error_for_missing_command: _FOR var _IN _RANGE (INT | var_access) _TO (INT | var_access) _EOL
_error_assign_list_missign_right_bracket: var  (_IS | _EQUALS) _LEFT_SQUARE_BRACKET ((INT | atom | list_access | expression | quoted_text | error_list_access_at) _COMMA (INT | atom | list_access | expression | quoted_text | error_list_access_at) (_COMMA (INT | atom | list_access | expression | quoted_text | error_list_access_at))*)? _SPACE?
_error_assign_list_missign_left_bracket: var  (_IS | _EQUALS) ((INT | atom | list_access | expression | quoted_text | error_list_access_at) _COMMA (INT | atom | list_access | expression | quoted_text | error_list_access_at) (_COMMA (INT | atom | list_access | expression | quoted_text | error_list_access_at))*)? _RIGHT_SQUARE_BRACKET _SPACE?
_error_assign_list_missing_both_brackets: var  (_IS | _EQUALS) ((INT | atom | list_access | expression | quoted_text | error_list_access_at) _COMMA (INT | atom | list_access | expression | quoted_text | error_list_access_at) (_COMMA (INT | atom | list_access | expression | quoted_text | error_list_access_at))*)? _SPACE?
error_assign_list_missing_brackets: _error_assign_list_missign_right_bracket | _error_assign_list_missign_left_bracket | _error_assign_list_missing_both_brackets

// allow == from now
condition:+= equality_check_dequals

equality_check_dequals: comparison_arg _DOUBLE_EQUALS comparison_arg _SPACE?
equality_check: comparison_arg (_IS | _EQUALS) comparison_arg _SPACE?

// all literal strings have to be quoted now, so arithmetic operators don't need to be excluded anymore
text_with_spaces_without_single_quotes: /(?:[^\n،,' ]| (?!<expand_keyword else>))+/ -> text
text_with_spaces_without_double_quotes: /(?:[^\n،," ]| (?!<expand_keyword else>))+/ -> text
text_in_quotes: _SINGLE_QUOTE text_with_spaces_without_single_quotes? _SINGLE_QUOTE | _DOUBLE_QUOTE text_with_spaces_without_double_quotes? _DOUBLE_QUOTE
textwithoutspaces: /(?:[^#\n،,，、 *+\-\/\(\)e]|e(?!lse ))+/ _END_BLOCK* -> text
?comparison_arg: call | boolean | var_access | list_access | error_list_access_at | text_in_quotes | NUMBER
//------------------------------------

// FUNCTIONS =====================================================================

define: (_DEF | "define ") function_name _LEFT_BRACKET? (arguments)? _RIGHT_BRACKET? _COLON? _EOL _commands _EOL? _END_BLOCK
call.-100: function_name _LEFT_BRACKET arguments? _RIGHT_BRACKET //make sure call goes below input, which looks the same

boolean: TRUE | FALSE
//TODO not sure yet if I can make brackets optional with a function call?
// FH June 2025: New to allow decimals in the grammar
?atom: NUMBER | _MINUS NUMBER | boolean | text_in_quotes | list_access | error_list_access_at | var_access // no more text without quotes

// The atom for the print ask needs its own var_access
?print_ask_atom: NUMBER | _MINUS NUMBER | boolean | text_in_quotes | list_access | error_list_access_at | var_access_print

?arguments: argument (_COMMA argument)* -> arguments
?argument: expression | atom | list_access | error_list_access_at | quoted_text

function_name: NAME -> text

?return: _RETURN (_print_ask_argument)? -> returns
?turtle_color:+= call

in_list_check: (list_access | error_list_access_at | var_access | text_in_quotes | atom) _IN var_access
not_in_list_check: (list_access | error_list_access_at | var_access | text_in_quotes | atom) _NOT_IN var_access

add: _ADD_LIST (atom | list_access | error_list_access_at | call) _TO_LIST _SPACE var_access
remove: _REMOVE (atom | list_access | error_list_access_at | call) _FROM _SPACE var_access

error_list_access_at:<old_rule_to_error list_access>

turtle: _FORWARD ((atom | list_access | textwithoutspaces | expression | error_list_access_at ))? -> forward | _TURN ((atom | list_access | textwithoutspaces | expression | error_list_access_at))? -> turn | _COLOR (turtle_color)? -> color
sleep: _SLEEP (atom | list_access | textwithoutspaces | expression | error_list_access_at )?

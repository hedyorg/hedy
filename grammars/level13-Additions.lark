// from now on we use (something very similar to)
// Python syntax
// colons and brackets however can be omitted in most places


// optional colons
for_list: _FOR var _IN var_access (_COLON)? _EOL (_SPACE command) (_EOL _SPACE command)* _EOL? _END_BLOCK

// optional brackets
print: _PRINT _LEFT_BRACKET? (_print_ask_argument)? _RIGHT_BRACKET?

// optional commas between arguments
_print_ask_argument: (_SPACE | list_access |var_access | quoted_text | _COMMA)*

//optional colon in if/elses
_if_clause: _IF (_conditions) _COLON? _EOL _commands _EOL? _END_BLOCK
_else_clause: _SPACE* _ELSE _COLON _EOL _commands _EOL? _END_BLOCK
_elif_clause: _SPACE* _ELIF (_conditions) _COLON _EOL _commands _EOL? _END_BLOCK

//add input
input_empty_brackets: var (_IS | _EQUALS ) _INPUT (_LEFT_BRACKET _RIGHT_BRACKET)
input: var (_IS | _EQUALS) _INPUT _LEFT_BRACKET _print_ask_argument+ _RIGHT_BRACKET

//new : while loop with optional colon
while_loop: _WHILE (_conditions) _COLON? _EOL _commands _EOL? _END_BLOCK

//list access with mandatory (!!) brackets
list_access: var_access _LEFT_SQUARE_BRACKET (INT | random | var_access) _RIGHT_SQUARE_BRACKET
change_list_item: var_access _LEFT_SQUARE_BRACKET (INT | var_access) _RIGHT_SQUARE_BRACKET _EQUALS (var_access | quoted_text | NUMBER  | list_access)
assign: var (_IS | _EQUALS) (INT | list_access | expression | quoted_text) _SPACE?
assign_list: var (_IS | _EQUALS) _LEFT_SQUARE_BRACKET ((quoted_text | NUMBER ) (_COMMA (quoted_text | NUMBER ))*)? _RIGHT_SQUARE_BRACKET

// adding the new commands
command: += while_loop | for_loop | input | input_empty_brackets | define | call | return | error_for_missing_in | error_for_missing_to | error_for_missing_command

//new : for loop
for_loop: _FOR var _IN _RANGE _LEFT_BRACKET? (INT | var_access) _COMMA (INT | var_access) _RIGHT_BRACKET? _COLON? _EOL (_SPACE command) (_EOL _SPACE command)*  _EOL? _END_BLOCK

error_for_missing_in: _FOR var _SPACE _RANGE (INT | var_access)? (_SPACE (INT | var_access))*
error_for_missing_to: _FOR var _IN _RANGE (INT | var_access) _SPACE (INT | var_access) _EOL
error_for_missing_command: _FOR var _IN _RANGE (INT | var_access) _TO (INT | var_access) _EOL

// allow == from now
condition:+= equality_check_dequals

equality_check_dequals: comparison_arg _DOUBLE_EQUALS comparison_arg _SPACE?

// all literal strings have to be quoted now, so arithmetic operators don't need to be excluded anymore
text_with_spaces_without_single_quotes: /(?:[^\n،,' ]| (?!<expand_keyword else>))+/ -> text
text_with_spaces_without_double_quotes: /(?:[^\n،," ]| (?!<expand_keyword else>))+/ -> text
text_in_quotes: _SINGLE_QUOTE text_with_spaces_without_single_quotes? _SINGLE_QUOTE | _DOUBLE_QUOTE text_with_spaces_without_double_quotes? _DOUBLE_QUOTE

?comparison_arg: call | var_access | list_access | text_in_quotes | NUMBER
//------------------------------------

// FUNCTIONS =====================================================================

define: (_DEF | "define ") function_name _LEFT_BRACKET? (arguments)? _RIGHT_BRACKET? _COLON? _EOL _commands _EOL? _END_BLOCK
call.-100: function_name _LEFT_BRACKET arguments? _RIGHT_BRACKET //make sure call goes below input, which looks the same

//TODO not sure yet if I can make brackets optional with a function call?
// FH June 2025: New to allow decimals in the grammar
?atom: NUMBER | _MINUS NUMBER | var_access // no more text without quotes


?arguments: argument (_COMMA argument)* -> arguments
?argument: expression | atom | list_access | quoted_text

function_name: NAME -> text

?return: _RETURN (_print_ask_argument)? -> returns
?simple_expression:+= call
?turtle_color:+= call

add: _ADD_LIST (atom | list_access | call) _TO_LIST _SPACE var_access
remove: _REMOVE (atom | list_access | call) _FROM _SPACE var_access
// ================================================================================

// From level 13 on, we support full Python syntax
// but done loosely, so you might forget some things (like :)
// adds comparisons

// old level 14
condition:+= equality_check_dequals | smaller | bigger | not_equal | smaller_equal | bigger_equal

equality_check: comparison_arg (_IS | _EQUALS) comparison_arg _SPACE?
equality_check_dequals: comparison_arg _DOUBLE_EQUALS comparison_arg _SPACE?
smaller: comparison_arg _SMALLER comparison_arg _SPACE?
bigger: comparison_arg _LARGER comparison_arg _SPACE?
smaller_equal: comparison_arg _SMALLER_EQUALS comparison_arg _SPACE?
bigger_equal: comparison_arg _LARGER_EQUALS comparison_arg _SPACE?
not_equal: comparison_arg _NOT_EQUALS comparison_arg _SPACE?

?comparison_arg: call | var_access | list_access | text_in_quotes | NUMBER

// old level 15 adds while loop

command: += while_loop | if_pressed -= error_if_pressed_missing_else >> error_ifelse | ifs

// new: boolean type and while loop
boolean: TRUE | FALSE

?atom: NUMBER | _MINUS NUMBER | boolean | text_in_quotes | var_access
assign_list: var (_IS| _EQUALS) (text_in_quotes|NUMBER|boolean) (_COMMA (text_in_quotes|NUMBER|boolean))+
?comparison_arg: += boolean >> var_access
?print_expression: += boolean >> var_access_print

while_loop: _WHILE (_conditions) _EOL (_SPACE command) (_EOL _SPACE command)* _EOL? _END_BLOCK

// old level 16
// list definition and list access are now done with brackets

command:+= change_list_item | error_assign_list_missing_brackets

?atom: NUMBER | _MINUS NUMBER | boolean | list_access | text_in_quotes | var_access
list_access: var_access _LEFT_SQUARE_BRACKET (INT | random | var_access) _RIGHT_SQUARE_BRACKET
change_list_item: var_access _LEFT_SQUARE_BRACKET (INT | var_access) _RIGHT_SQUARE_BRACKET _EQUALS (var_access | quoted_text | NUMBER | boolean | list_access)
assign_list: var (_IS | _EQUALS) _LEFT_SQUARE_BRACKET ((quoted_text | NUMBER | boolean) (_COMMA (quoted_text | NUMBER | boolean))*)? _RIGHT_SQUARE_BRACKET
error_assign_list_missing_brackets: var  (_IS | _EQUALS) (_LEFT_SQUARE_BRACKET)? ((quoted_text | NUMBER | boolean) _COMMA (quoted_text | NUMBER | boolean) (_COMMA (quoted_text | NUMBER | boolean))*)? (_RIGHT_SQUARE_BRACKET)?

error_list_access_at:<old_rule_to_error list_access>

_print_ask_argument.1: (_SPACE | quoted_text | list_access | error_list_access_at | expression | print_expression)*
assign: var (_IS| _EQUALS) (list_access | error_list_access_at | boolean | atom | expression)
error_print_no_quotes: _PRINT (textwithoutspaces | list_access | error_list_access_at | var_access) (_SPACE (textwithoutspaces | list_access | var_access))*  -> error_print_nq
sleep: _SLEEP (INT | list_access | error_list_access_at | var_access | expression)?
turtle: _FORWARD ((NUMBER | list_access | error_list_access_at | textwithoutspaces | expression))? -> forward | _TURN ((NUMBER | list_access | error_list_access_at | textwithoutspaces | expression))? -> turn | _COLOR ((black | blue | brown | gray | green | orange | pink | purple | red | white | yellow | list_access | error_list_access_at | textwithoutspaces))? -> color



// old level 17

// In this level we add a colon to if-else statements, function definitions, and loops.
// The `<rule_name>` syntax specifies a preprocessor rule which would be applied in the grammar merger.
// The merger will find the appropriate function for this annotation and modify it accordingly.
// The preprocessor can also accept a parameter via the syntax <rule_name argument>.

command: += (if_pressed | if_pressed_no_colon) (if_pressed_elifs | if_pressed_elifs_no_colon)* (if_pressed_elses | if_pressed_elses_no_colon)? | (ifs | ifs_no_colon) (elifs | elifs_no_colon)* (elses | elses_no_colon)? | for_list_no_colon | for_loop_no_colon | while_loop_no_colon | define_no_colon -= ifs elses?

if_pressed:<needs_colon>
if_pressed_no_colon:<old_rule_to_error if_pressed>

if_pressed_else:<needs_colon>

if_pressed_elses:<needs_colon>
if_pressed_elses_no_colon:<old_rule_to_error if_pressed_elses>

if_pressed_elifs: _EOL _ELIF (LETTER_OR_NUMERAL | NAME) _IS _PRESSED _COLON _EOL (_SPACE command) (_EOL _SPACE command)* _EOL? _END_BLOCK
if_pressed_elifs_no_colon: _EOL _ELIF (LETTER_OR_NUMERAL | NAME) _IS _PRESSED _EOL (_SPACE command) (_EOL _SPACE command)* _EOL? _END_BLOCK



ifs:<needs_colon>
ifs_no_colon:<old_rule_to_error ifs>

elses:<needs_colon>
elses_no_colon:<old_rule_to_error elses>

elifs: _EOL _ELIF _conditions _COLON _EOL (_SPACE command) (_EOL _SPACE command)* _EOL? _END_BLOCK
elifs_no_colon: _EOL _ELIF _conditions _EOL (_SPACE command) (_EOL _SPACE command)* _EOL? _END_BLOCK



for_list:<needs_colon>
for_list_no_colon:<old_rule_to_error for_list>

for_loop:<needs_colon>
for_loop_no_colon:<old_rule_to_error for_loop>

while_loop:<needs_colon>
while_loop_no_colon:<old_rule_to_error while_loop>

define:<needs_colon>
define_no_colon:<old_rule_to_error define>


// old level 18
// adds round brackets in print() and range(), and changes ask to input

command: += input | input_empty_brackets | print_empty_brackets -= ask | error_ask_no_quotes | error_print_no_quotes >> assign | call
_if_less_command: -= ask | error_ask_no_quotes | error_print_no_quotes

print: _PRINT (_LEFT_BRACKET (quoted_text | list_access | print_expression) (_COMMA (quoted_text | list_access | print_expression))* _RIGHT_BRACKET)?
print_empty_brackets: _PRINT _LEFT_BRACKET _RIGHT_BRACKET
input_empty_brackets: var (_IS | _EQUALS ) _INPUT (_LEFT_BRACKET _RIGHT_BRACKET)
input: var (_IS | _EQUALS) _INPUT (_LEFT_BRACKET  ((quoted_text | list_access | print_expression) (_COMMA (quoted_text | list_access | print_expression))*) _RIGHT_BRACKET)?
for_loop: _FOR var _IN _RANGE _LEFT_BRACKET (POSITIVE_NUMBER | var_access) _COMMA (NUMBER | var_access) (_COMMA (POSITIVE_NUMBER | var_access))? _RIGHT_BRACKET _COLON _EOL (_SPACE command) (_EOL _SPACE command)* _EOL? _END_BLOCK

?print_expression: NUMBER | expression | var_access

define: _DEF function_name _LEFT_BRACKET (arguments)? _RIGHT_BRACKET _COLON _EOL _SPACE command (_EOL _SPACE command)* _EOL? _END_BLOCK
call: function_name _LEFT_BRACKET (arguments)? _RIGHT_BRACKET
